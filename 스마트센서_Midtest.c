#pragma config(Sensor, S1,     ts,             sensorEV3_Touch)
#pragma config(Sensor, S2,     gs,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     cs,             sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     ss,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          lm,            tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rm,            tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define Black 1
#define Blue 2
#define Green 3
#define Yellow 4
#define Red 5
#define White 6
#define Brown 7

//sICT3

int black_line = 0;

int r,g, b;
int speed = 12;
//radian to distance
int convert(float dist){
	return (int)(360.0 * dist / 17.58);
}

//detect RGB
int RGB(int r, int g, int b){
	if (r == 0 || g == 0 || b == 0){return White;}
	else if (g >= 80) {return White;}
	else if (r >= 30){
		if (g >= 30 && b >= 30) return White; // White value
		else if (g >= 15) return Yellow;
		else return Red;
	}
	else{
	  if (g>=20) return Green;
		else if (g >= 10 && b >= 20) return Blue;
		else return Black;
	}
}

void go(int s){
	setMotorSpeed(lm, s);
	setMotorSpeed(rm, s);
}

void black_check(){
		black_line += 1;
		sleep(600);
}

void blue_check(){
		if (black_line == 0) {
			playSound(soundBeepBeep);
			sleep(500);
		}
		else{
			for (int i = 0; i < black_line; i++){
					playSound(soundBeepBeep);
					sleep(500);
			}
		}
}

void red_check(){
	resetGyro(gs);
		while(getGyroDegrees(gs) >= -90)	{
					setMotorSpeed(lm, -speed/2);
					setMotorSpeed(rm, +speed/2);
		}

		setMotorSpeed(lm, 0);
		setMotorSpeed(rm, 0);
		sleep(500);

		resetMotorEncoder(lm);
		resetMotorEncoder(rm);

		int enc_degree = convert(10.0);
		setMotorTarget(lm, enc_degree * black_line, speed/2);
		setMotorTarget(rm, enc_degree * black_line, speed/2);
		waitUntilMotorStop(lm);

		resetGyro(gs);
		while(getGyroDegrees(gs) >= -90)	{
					setMotorSpeed(lm, -speed/2);
					setMotorSpeed(rm, +speed/2);}
		setMotorSpeed(lm, 0);
		setMotorSpeed(rm, 0);
		sleep(500);
}

task main()
{
	float t;

	int color, finish_line, start_val = 0;
	while(getTouchValue(ts) == 0){}
	while(getTouchValue(ts) == 1){}
	//if touch
	while (1) {
		int sum_r = 0; int sum_g = 0; int sum_b = 0;
		int max_r = 0; int max_g = 0; int max_b = 0;
		int min_r = 200; int min_g = 200; int min_b = 200;
		for (int i = 0; i < 9; i++){
				getColorRGB(cs, r, g, b);

				sum_r += r;
				sum_g += g;
				sum_b += b;
				if (max_r < r) max_r = r;
				if (max_g < g) max_g = g;
				if (max_b < b) max_b = b;

				if (min_r > r) min_r = r;
				if (min_g > g) min_g = g;
				if (min_b > b) min_b = b;

				sleep(20);
			}
			sum_r -= max_r;
			sum_r -= min_r;

			sum_g -= max_g;
			sum_g -= min_g;

			sum_b -= max_b;
			sum_b -= min_b;

			sum_r /= 8;
			sum_g /= 8;
			sum_b /= 8;

			color = RGB(sum_r, sum_g, sum_b);
			go(speed);

			if ((color != White) && (!start_val)){
				finish_line = color;
				clearTimer(T1);
				setLEDColor(ledGreen); // check **
				start_val += 1;
			sleep(1200);
			}

			// if finish_line
			else if (color == finish_line || black_line == 10){
					t = time1[T1];
					go(0);

				displayBigTextLine(1, "recm+ord = %.2f sec", t/1000);
				sleep(500);
				break;
			}
			displayBigTextLine(1, "%d", black_line);
			displayBigTextLine(5, "%d %d %d", r, g, b);
			if (color == Black){black_check();}
			if (color == Blue) {blue_check();}
			if (color == Red){red_check();}
		}
 }
